{"version":3,"sources":["constants/api.js","api/giphy.js","actions/giphy.js","utils/giphy-util.js","hooks/useDebouncedCallback.js","contexts/ThemeProvider.js","components/ThemeToggler.js","components/ImageRenderer.js","components/GIFContainer.js","components/CustomInput.js","components/Home.js","reducers/giphy.js","index.js","store.js"],"names":["API_KEY","process","BASE_URL","getGiphyURL","offset","query","limit","url","getGiphyTrendingURL","a","fetch","response","json","fetchGiphySuccess","payload","type","fetchGiphyInProgress","startGiphyFetch","dispatch","startGiphySearchAPI","then","items","data","startGiphyTrendingFetch","startGiphyTrendingAPI","debounce","callback","delay","timer","args","arguments","context","this","clearTimeout","setTimeout","apply","useDebouncedCallback","config","debouncedCallback","React","useMemo","ThemeContext","createContext","themeFromLocalStorage","localStorage","getItem","ThemeProvider","props","useState","theme","setTheme","useEffect","document","querySelector","className","Provider","value","updateTheme","setItem","children","useThemeContext","useContext","undefined","Error","ThemeToggler","lightText","darkText","toggleText","id","onClick","ImageRenderer","key","src","width","height","lastImage","alt","loaderref","imageRef","useRef","img","current","onload","style","visibility","ref","GIFContainer","gifsToAppend","loading","results","setResults","newGifsToAppend","wordsPerLine","Math","ceil","length","line","i","push","makeChunk","res","map","gif","index","arr","images","original","title","CustomInput","onChangeCallback","placeholder","onChange","connect","state","newItemsAdded","bindActionCreators","observer","setOffset","setQuery","debouncedQuerySearch","e","searchText","target","intersectionCallback","useCallback","entries","isIntersecting","debouncedIntersectionCallback","toBeObserved","IntersectionObserver","root","rootMargin","threshold","observe","unobserve","initialState","giphy","action","store","createStore","applyMiddleware","logger","thunk","storeCreator","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.0973f5a6.chunk.js","sourcesContent":["const API_KEY = process.env.REACT_APP_GIPHY_API_KEY\nconst BASE_URL =  process.env.REACT_APP_BASE_URL\n\n\n/**\n * API for finding Trending GIFs\n * @param {*} offset \n * @param {*} query \n * @param {*} limit \n */\nexport const getGiphyURL = function (\n  offset = 0,\n  query = \"cheeseburgers\",\n  limit = 20\n) {\n  var url = `${BASE_URL}/v1/gifs/search?api_key=${API_KEY}&&q=${query}&&limit=${limit}&&offset=${offset}&&random_id=e826c9fc5c929e0d6c6d423841a282aa`;\n  return url;\n};\n\n/**\n * API for searching GIFs by query\n * @param {*} offset \n * @param {*} limit \n */\nexport const getGiphyTrendingURL = function (\n    offset = 0,\n    limit = 20\n  ) {\n    var url = `${BASE_URL}/v1/gifs/trending?api_key=${API_KEY}&&limit=${limit}&&offset=${offset}&&random_id=e826c9fc5c929e0d6c6d423841a282aa`;\n    return url;\n  };\n\n","import { getGiphyURL,getGiphyTrendingURL } from \"../constants/api\";\n\nexport async function startGiphySearchAPI(offset, query) {\n  const response = await fetch(getGiphyURL(offset, query));\n  const json = response.json();\n  return json;\n}\n\nexport async function startGiphyTrendingAPI(offset) {\n    const response = await fetch(getGiphyTrendingURL(offset));\n    const json = response.json();\n    return json;\n  }\n","import {startGiphySearchAPI,startGiphyTrendingAPI} from \"../api/giphy\";\n\nexport const fetchGiphySuccess = (payload, offset) => {\n  return { type: \"FETCH_GIPHY_SUCCESS\", payload, offset };\n};\n\nexport const fetchGiphyInProgress = () => {\n  return { type: \"FETCH_IN_PROGRESS\"};\n};\n\n// Redux-Thunk (Async Action)\nexport const startGiphyFetch = (offset, query) => (dispatch) => {\n  startGiphySearchAPI(offset, query).then((items) => {\n    dispatch(fetchGiphySuccess(items.data, offset));\n  });\n};\n\n\nexport const startGiphyTrendingFetch = (offset) => (dispatch) => {\n  startGiphyTrendingAPI(offset).then((items) => {\n    dispatch(fetchGiphySuccess(items.data, offset));\n  });\n};\n","export function debounce(callback, delay) {\n  let timer;\n  return function () {\n    const args = arguments;\n    const context = this;\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => callback.apply(context, args), delay);\n  };\n}\n","import React from \"react\";\nimport {debounce} from \"../utils/giphy-util\";\n\n/**\n * Custom Hook for debouncing any callback with specified delay\n * To Note : The result is memoised so that multiple renders don't result in re-execution of\n * debounce function\n * @param  {...any} config \n */\nfunction useDebouncedCallback(...config) {\n  const [callback, delay] = config;\n  const debouncedCallback = React.useMemo(() => debounce(callback, delay), [\n    delay,\n    callback\n  ]);\n  return debouncedCallback;\n}\n\nexport default useDebouncedCallback;\n","import React from \"react\";\n\nconst ThemeContext = React.createContext();\nconst themeFromLocalStorage = localStorage.getItem(\"theme\");\n\nexport function ThemeProvider(props) {\n  const [theme, setTheme] = React.useState(themeFromLocalStorage || \"dark\");\n\n  /**\n   * Storing the theme in localstorage for future visits\n   */\n  const updateTheme = (theme) => {\n    setTheme(theme);\n    localStorage.setItem(\"theme\", theme);\n  };\n\n  /**\n   * This effect has global logic of how theme can be used.\n   * Children can also have their overriding effects\n   */\n  React.useEffect(() => {\n    document.querySelector(\"html\").className = theme;\n  }, [theme]);\n\n  return (\n    <ThemeContext.Provider value={{ theme, updateTheme }}>\n      {props.children}\n    </ThemeContext.Provider>\n  );\n}\n\nexport function useThemeContext() {\n  const context = React.useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error(\n      \"useThemeContext must be used within a ThemeContextProvider\"\n    );\n  }\n  return context;\n}\n","import { useThemeContext } from \"../contexts/ThemeProvider\";\n\nfunction ThemeToggler(props) {\n  const { theme, updateTheme } = useThemeContext();\n  const { lightText, darkText } = props;\n\n  const toggleTheme = () => {\n    updateTheme(theme === \"light\" ? \"dark\" : \"light\");\n  };\n\n  const toggleText = theme === \"light\" ? darkText : lightText;\n\n  return (\n    <div id=\"theme-toggler\" onClick={toggleTheme}>\n      {toggleText}\n    </div>\n  );\n}\n\nexport default ThemeToggler;\n","import React from \"react\";\n\nfunction ImageRenderer(props) {\n  const {\n    key,\n    src,\n    width,\n    height,\n    lastImage,\n    alt,\n    loaderref = null,\n    className = null,\n  } = props;\n\n  const imageRef = React.useRef();\n\n  React.useEffect(() => {\n    // Placeholder effect\n    // Preload Image and swap to avoid janks on slow network\n    const img = imageRef.current;\n    img.src = src;\n    img.onload = function onload() {\n      img.style.visibility = \"visible\"; // hidden initially\n      imageRef.current = null;\n    };\n  }, []);\n\n  return (\n    <div>\n      <img\n        id={key}\n        width={width}\n        height={height}\n        ref={imageRef}\n        key={key}\n        src={src}\n        alt={alt}\n        className={className}\n      />\n      {lastImage && <div ref={loaderref}></div>}\n    </div>\n  );\n}\n\nexport default ImageRenderer;\n","import React from \"react\";\nimport \"./styles/GIFContainer.css\";\nimport ImageRenderer from \"./ImageRenderer\";\n\nfunction GIFContainer(props) {\n  const { gifsToAppend, loaderref, offset,loading } = props;\n  const [results, setResults] = React.useState([[], [], [], []]);\n\n  React.useEffect(() => {\n    const n = 4;\n\n    const newGifsToAppend = [[], [], [], []]; //we create it, then we'll fill it\n\n    const wordsPerLine = Math.ceil(gifsToAppend.length / 4);\n\n    for (let line = 0; line < n; line++) {\n      for (let i = 0; i < wordsPerLine; i++) {\n        const value = gifsToAppend[i + line * wordsPerLine];\n        if (!value) continue; //avoid adding \"undefined\" values\n        newGifsToAppend[line].push(value);\n      }\n    }\n    if (offset === 1) {\n      setResults([\n        [...newGifsToAppend[0]],\n        [...newGifsToAppend[1]],\n        [...newGifsToAppend[2]],\n        [...newGifsToAppend[3]],\n      ]);\n    } else\n      setResults((results) => [\n        [...results[0], ...newGifsToAppend[0]],\n        [...results[1], ...newGifsToAppend[1]],\n        [...results[2], ...newGifsToAppend[2]],\n        [...results[3], ...newGifsToAppend[3]],\n      ]);\n  }, [gifsToAppend,offset]);\n\n  const makeChunk = (res, i = \"0\") => {\n    return res.map((gif, index, arr) => {\n      if (i === 3 && index === arr.length - 1) {\n        return (\n          <ImageRenderer\n            loaderref={loaderref}\n            src={gif.images.original.url}\n            width={gif.images.original.width}\n            height={gif.images.original.height}\n            lastImage={true}\n            alt={gif.title}\n            className=\"gif-img\"\n          />\n        );\n      } else {\n        return (\n          <ImageRenderer\n            width={gif.images.original.width}\n            height={gif.images.original.height}\n            src={gif.images.original.url}\n            alt={gif.title}\n            className=\"gif-img\"\n          />\n        );\n      }\n    });\n  };\n\n  if(loading)\n  return null\n\n  return (\n    <div className=\"row\">\n      <div className=\"column\" >\n        {makeChunk(results[0])}\n      </div>\n      <div className=\"column\" >\n        {makeChunk(results[1])}\n      </div>\n      <div className=\"column\" >\n        {makeChunk(results[2])}\n      </div>\n      <div className=\"column\">\n        {makeChunk(results[3], 3)}\n      </div>\n    </div>\n  );\n}\n\nexport default GIFContainer;\n","function CustomInput(props) {\n  const { onChangeCallback, placeholder, id } = props;\n  return (\n    <input id={id} placeholder={placeholder} onChange={onChangeCallback} />\n  );\n}\n\nexport default CustomInput;\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { startGiphyFetch, startGiphyTrendingFetch,fetchGiphyInProgress } from \"../actions/giphy\";\nimport { bindActionCreators } from \"redux\";\nimport useDebouncedCallback from \"../hooks/useDebouncedCallback\";\nimport \"./styles/Home.css\";\nimport { useThemeContext } from \"../contexts/ThemeProvider\";\nimport ThemeToggler from \"./ThemeToggler\";\nimport GIFContainer from \"./GIFContainer\";\nimport CustomInput from \"./CustomInput\";\n\nfunction Home(props) {\n  const { startGiphyFetch, startGiphyTrendingFetch, newItemsAdded ,loading,fetchGiphyInProgress} = props;\n  const loaderref = React.useRef();\n  const observer = React.useRef();\n  const [offset, setOffset] = React.useState(1);\n  const [query, setQuery] = React.useState(\"\");\n\n  /**\n   * Custom React Context to get the theme\n   */\n  const { theme } = useThemeContext();\n\n  /**\n   * Debouncing the Query Search to save extra network calls\n   */\n  const debouncedQuerySearch = useDebouncedCallback((e) => {\n    const searchText = e.target.value;\n    setQuery(searchText);\n  }, 200);\n\n  /**\n   * Effect based upon query search\n   * Reset the offset to 1.\n   * Triggers the actions for offset 1\n   */\n  React.useEffect(() => {\n    setOffset(1);\n    fetchGiphyInProgress()\n    if (query) startGiphyFetch(1, query);\n    else startGiphyTrendingFetch(1);\n  }, [query, startGiphyFetch, startGiphyTrendingFetch]);\n\n  /**\n   *\n   * Infinite Scrolling :\n   * Effect based upon offset ( >1 )\n   * Keeping 'query' same when offset changes\n   * If query is empty, it fetches the trending GIFS\n   *\n   */\n  React.useEffect(() => {\n    if (offset > 1) {\n      if (query) startGiphyFetch(offset, query);\n      else startGiphyTrendingFetch(offset);\n    }\n  }, [offset, startGiphyFetch, startGiphyTrendingFetch]);\n\n  /**\n   * Optimised Intersection Callback :\n   * useCallback prevents re-creation of this callback across re-renders\n   */\n  const intersectionCallback = React.useCallback((entries) => {\n    if (entries[0].isIntersecting) {\n      setOffset((offset) => offset + 1);\n    }\n  }, []);\n\n  /**\n   * This callback would be called when target is in viewport.\n   * Debouncing it, to avoid extra calls.\n   */\n  const debouncedIntersectionCallback = useDebouncedCallback(\n    intersectionCallback,\n    5\n  );\n\n  /**\n   * Effect :\n   * Intersection Observer will observe the last GIF (target) on web page.\n   * The Observer should be re-created when the last GIF on webpage changes.\n   * So, using [items] as dependency of this hook\n   */\n  React.useEffect(\n    () =>\n      setTimeout(() => {\n        const toBeObserved = loaderref.current;\n        observer.current = new IntersectionObserver(\n          debouncedIntersectionCallback,\n          {\n            root: null,\n            rootMargin: \"100px\",\n            threshold: 0,\n          }\n        );\n\n        if (toBeObserved) observer.current.observe(toBeObserved);\n\n        return () => {\n          if (toBeObserved) observer.current.unobserve(toBeObserved);\n        };\n      }, 0),\n    [debouncedIntersectionCallback, newItemsAdded, loaderref]\n  );\n\n  /**\n   * Global Theme Logic is present in Theme provider\n   * Any custom Logic/Overriding can be used like this in child components\n   */\n  React.useEffect(() => {\n    document.querySelector(\"#theme-toggler\").className = theme;\n    document.querySelector(\"input\").className = theme;\n  }, [theme]);\n\n  return (\n    <div id=\"gif-dashboard\">\n      <div className=\"gif-query-container\">\n        <CustomInput\n          id=\"gif-query-input\"\n          placeholder=\"Search your favourite GIFs\"\n          onChangeCallback={debouncedQuerySearch}\n        />\n        <ThemeToggler\n          darkText=\"Switch to Dark Mode\"\n          lightText=\"Switch to Light Mode\"\n        />\n      </div>\n      <GIFContainer\n        gifsToAppend={newItemsAdded}\n        offset={offset}\n        loaderref={loaderref}\n        loading={loading}\n      />\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => {\n  return {\n    newItemsAdded: state.newItemsAdded,\n    loading:state.loading\n  };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return bindActionCreators(\n    {\n      startGiphyFetch,\n      startGiphyTrendingFetch,\n      fetchGiphyInProgress\n    },\n    dispatch\n  );\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Home);\n","const initialState = {\n  newItemsAdded:[],\n  loading:true\n};\n\nconst giphy = (state = initialState, action) => {\n  switch (action.type) {\n    case \"FETCH_GIPHY_SUCCESS\": {\n        return {\n          newItemsAdded:[...action.payload],\n          loading:false\n        };\n    }\n    case \"FETCH_IN_PROGRESS\":{\n      return {\n        ...state,\n        loading :true\n      }\n    }\n    default:\n      return state;\n  }\n};\n\nexport default giphy;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport Home from \"./components/Home\";\nimport storeCreator from \"./store\";\nimport { Provider } from \"react-redux\";\nimport { ThemeProvider } from \"./contexts/ThemeProvider\";\n\nconst store = storeCreator();\n\nReactDOM.render(\n  <Provider store={store}>\n    <ThemeProvider>\n      <Home />\n    </ThemeProvider>\n  </Provider>,\n  document.getElementById(\"root\")\n);\n","import { createStore, applyMiddleware } from \"redux\";\nimport giphy from \"./reducers/giphy\";\nimport logger from \"redux-logger\";\nimport thunk from \"redux-thunk\";\n\nconst storeCreator = () => {\n  return createStore(giphy, applyMiddleware(logger, thunk));\n};\n\nexport default storeCreator;\n"],"sourceRoot":""}